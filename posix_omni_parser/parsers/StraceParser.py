"""
<Started>
  July 2013

<Author>
  Savvas Savvides <savvas@purdue.edu>

<Purpose>
  This module holds a set of methods needed to parse the output of the strace utility. More 
  information about strace can be found in the manual page under most Linux platforms (man strace)

  The path to a file generated by the strace utility must be passed to the constructor method when 
  initializing a StraceParser object. Then the parse_trace method of the parser can be called, 
  which will return a list of Syscall objects, each containing all the information about a single 
  system call parsed from the strace output file.

  Example using this module:

    import StraceParser

    parser = StraceParser.StraceParser(path_to_trace)
    print parser

    # this will return a list of Syscall objects.
    syscalls = parser.parse_trace()

"""
from __future__ import print_function

from builtins import str
from builtins import range
import re

from .. import Syscall
from .Parser import Parser


DEBUG = False


class StraceParser(Parser):
    """
    <Purpose>
      This object holds the information necessary to parse a system call trace
      file generated by the strace tool, which can be found in Linux platforms.

    <Attributes>
      self.trace_path:
        The path to the file containing the traced system calls.

      self.syscall_definitions:
        A list of definitions describing each system call.

      self.trace_options:
        A dictionary of strace options and whether they were provided or not, when
        the current trace was being generated. See _detect_trace_options() for
        more information.

      self.home_env:
        This instance variable holds the contents of the HOME environment
        variable, if this information can be extracted from the trace file itself.

      self._re_unfinished_syscall,
      self._re_resumed_syscall,
      self._re_complete_syscall:
        Regular expressions used to parse lines of the strace output. Each line of
        the strace output represents a system call.
    """

    def __init__(self, trace_path, pickle_file):
        """
        <Purpose>
          Creates an StraceParser object containing all the information needed to
          extract data from a  trace file generated by the strace utility.

        <Arguments>
          trace_path:
            The path to the trace file containing the traced system calls. This file
            should contain the output of the strace utility.
          pickle_file:
            The path to the pickle file containing the parsed system call
            representations.

                                <Side Effects>
          None

        <Returns>
          None
        """

        Parser.__init__(self, trace_path, pickle_file)

        # regex compiled for _parse_line
        #
        # Example unfinished syscall.
        # accept(3,  <unfinished ...>
        #
        # Example complete syscall.
        # socket(PF_INET, SOCK_STREAM, IPPROTO_IP) = 5 <0.000066>
        #
        # Example resumed syscall.
        # <... accept resumed> {sa_family=AF_INET, sin_port=htons(44289), sin_addr=inet_addr("127.0.0.1")}, [16]) = 4 <0.002020>
        #
        # Example unfinished syscall due to end of program.
        # nanosleep({...},  <unfinished ... exit status 0>
        self._re_unfinished_syscall = re.compile(r"([^(]+)\((.*)\<unfinished .*")
        self._re_resumed_syscall = re.compile(
            r"\<\.\.\. ([^ ]+) resumed\> (.*)\)[ ]+=[ ]+([a-fx\d\-?]+)(.*)"
        )
        self._re_complete_syscall = re.compile(
            r"([^(]+)\((.*)\)[ ]+=[ ]+([a-fx\d\-?]+)(.*)"
        )

        # In the above we have:
        # ([^()]+)\( -- group that matches at least one character of anything except
        #               the opening bracket. (everything up to first bracket
        #               ie: pid, options and name)
        # \((.*)\) -- a group that matches any character. The group must appear
        #             within brackets (parameters)
        # =[ ]+([a-fx\d\-?]+) -- a group that matches at least on character of all
        #                        the ones given. (return part)
        # (.*) -- group that captures anything that comes after the return part.

        # Added this because parse_line only parses one line, and if that line is a
        # unfinished syscall, then it need to be recorded
        self.unfinished_syscalls = []

    def _get_home_environment(self):
        """
        <Purpose>
          Read the first line of the trace file. If that line represents the execve
          system call then examine it to see whether the HOME environment variable
          is set. If it is set, extract it and return it, otherwise return None. The
          HOME environment variable is sometimes set to a path other than the
          current directory i.e the directory in which the traced application was
          executed. This usually happens when running a benchmarks. Keeping track of
          the HOME env. variable is particularly useful when reasoning about
          relative paths that appear in the trace file. System calls referring to
          files using relative paths, might refer to these files relative to the
          HOME variable defined in the execve syscall.

        <Arguments>
          None

        <Exceptions>
          IOError:
            Unable to read from the trace file.

        <Side Effects>
          None

        <Returns>
          The HOME env path as defined in the execve system call, or None if the
          HOME path was not found.
        """

        try:
            fh = open(self.trace_path, "r")
            # the execve syscall is the first action of the trace file
            execve_line = fh.readline()
        except IOError:
            raise IOError(
                "Unable to read trace file when trying to extract the "
                + "HOME environment variable."
            )
        finally:
            fh.close()

        # If the 'HOME' variable is defined in the execve line, the HOME_PATH variable will be set
        # to the path of 'HOME'.
        if "execve(" in execve_line:
            # split to get the arguments of the syscall
            execve_parts = execve_line.split(", ")

            # the parameter of the HOME variable in the execve syscall has this
            # format:
            # "HOME=/home/savvas/tests/" including the double quotes.
            for part in execve_parts:
                if part.startswith('"HOME='):
                    # remove the double quotes
                    part = part.strip('"')

                    # return the path excluding the "HOME="" label in front of it.
                    return part[part.find("HOME=") + 5 :]

        return None

    def _detect_trace_options(self):
        """
        <Purpose>
          The strace parser can parse the output generated by the strace utility and
          can recognize different output formats based on the set of strace options
          used when gathering traces. In fact some of these options are required
          which means that the strace parser will complain if it determines that
          these options were not used. Some other options are entirely optional and
          can be skipped.

          The set of options the strace parser can handle. Description copied from
          strace man page. (R) indicates a required option:

          -i     Print the instruction pointer at the time of the system call.
          -r     Print a relative timestamp upon entry to each system call. This
                 records the time difference between the beginning of successive
                 system calls.
          -t     Prefix each line of the trace with the time of day.
          -tt    If given twice, the time printed will include the microseconds.
          -ttt   If given thrice, the time printed will include the microseconds and
                 the leading portion will be printed as the number of seconds since
                 the epoch.
          -T     Show the time spent in system calls. This records the time difference
                 between the beginning and the end of each system call.
          -v     Print unabbreviated versions of environment, stat, termios etc calls.
                 These structures are very common in calls and so the default behavior
                 displays a reasonable subset of structure members. Use this option to
                 get all of the gory details.
          -s #   Specify the maximum string size to print (the default is 32). Note
                 that filenames are not considered strings and are always printed in
                 full.
          -o (R) Write the trace output to a file rather than to stderr.
          -f (R) Trace child processes as they are created by currently traced
                 processes as a line_parts of the fork(2) system call.

          Note:  The parser requires each traced system call to include the process
                 id. This is achieved by using both the -f and -o options when
                 tracing an application. Hence these two options are required. The
                 reason we need the pid in each system call is because we use it to
                 identify the corresponding unfinished syscall for every resuming
                 syscalls.

          Example strace output with different options. Required options -f and -o
          are included in each of the following examples.

          with no extra options (other than -o and -f):

            8085  open("syscalls.txt", O_RDONLY|O_CREAT, 0664) = 3
          -v:
            without:
              execve("/bin/ls", ["ls"], [/* 51 vars */]) = 0
            with:
              execve("/bin/ls", ["ls"], ["MANPATH=/etc/java-config-2/curre"...,
              "ORBIT_SOCKETDIR=/tmp/orbit-ssavv"..., "XDG_MENU_PREFIX=gnome-",
              "SHELL=/usr/local/bin/bash", "TERM=xterm", "WINDOWID=25165827",
              "SHLVL=3", "ICAROOT=/opt/Citrix/ICAClient", "HOME=/homes/ssavvide",
              "JDK_HOME=/etc/java-config-2/curr"...,
              "GNOME_DESKTOP_SESSION_ID=this-is"..., "LOGNAME=ssavvide",
              "LESS=-R -M --shift 5", "CUR_WIDTH=77", "CVS_RSH=ssh", "GCC_SPECS=",
              "DBUS_SESSION_BUS_ADDRESS=unix:ab"...,
              "DBUS_SYSTEM_BUS_ADDRESS=unix:pat"..., "COLORTERM=gnome-terminal",
              "OLDPWD=/homes/ssavvide/programmi"...]) = 0

          -s:
            without(default is 32 characters. Everything else is truncated with ...):
              write(1, "plugins\t\t\t      syscall_definiti"..., 43) = 43
            with:
              write(1, "plugins\t\t\t      syscall_definitions.pickle\n", 43) = 43

          -i:
            8088  [b7739424] open("syscalls.txt", O_RDONLY|O_CREAT, 0664) = 3
          -r:
            8091  0.000539 open("syscalls.txt", O_RDONLY|O_CREAT, 0664) = 3
          -t:
            8094  15:31:56 open("syscalls.txt", O_RDONLY|O_CREAT, 0664) = 3
          -tt:
            8097  15:32:16.190216 open("syscalls.txt", O_RDONLY|O_CREAT, 0664) = 3
          -ttt:
            8100  1371472360.671434 open("syscalls.txt", O_RDONLY|O_CREAT, 0664) = 3
          -T:
            8106  open("syscalls.txt", O_RDONLY|O_CREAT, 0664) = 3 <0.000040>

          An example with all handled options: strace -irtttTvfo output_file command
            8112  0.000587 [b7795424] open("syscalls.txt", O_RDONLY|O_CREAT, 0664) = 3 <0.000037>

          Note here how the -r option overrules the -ttt (or -t or -tt) option. In
          other words the two following executions of strace have the exact same
          outcome:
            strace -irtttTvfo output_file command
            strace -irTvfo output_file command

          To get non-relative time stats skip the -r option:
            strace -itttTvfo output_file command
          Which will produce something like:
            8168  1371473138.416217 [b7782424] open("syscalls.txt", O_RDONLY|O_CREAT, 0664) = 3 <0.000037>

        <Arguments>
          None

        <Exceptions>
          None

        <Side Effects>
          None

        <Returns>
          A dictionary with options and whether they were provided or not.

          Name of Option    Possible Values           Corresponding strace Option
          -------------------------------------------------------------------------
          "output"          True/False                -o
          "fork"            True/False                -f
          "verbose"         True/False                -v
          "string_size"     None/int                  -s
          "timestamp"       None/"r"/"t"/"tt"/"ttt"   -r / -t / -tt / -ttt
          "elapsed_time"    True/False                -T
          "inst_pointer"    True/False                -i

          Here True means the option was given. False means the option was not
          given and None means we don't know whether the option was given or not.

          In case of string_size, None means we don't know. If we do know then
          string_size will hold a number indicating the size of strings (number of
          characters)

          In case of timestamp, None means no option related to timestamp was given.
          Otherwise the timestamp entry will hold the specific option given. This
          happens because there can only be one of these options. Note that if both
          -r and -t is given, the -r option dominates the -t option. That is strace
          will act as if only -r was given.

        """

        # initially assume that no option was used.
        trace_options = {}
        trace_options["output"] = False
        trace_options["fork"] = False
        trace_options["verbose"] = False
        trace_options["string_size"] = None
        trace_options["timestamp"] = None
        trace_options["elapsed_time"] = False
        trace_options["inst_pointer"] = False

        # read the first line of the trace to detect the used options. Traces that
        # represent application executions should start with a complete execve
        # system call. But to allow traces that are "made up" e.g for testing
        # purposes, let's not assume that the first syscall is always execve.
        try:
            fh = open(self.trace_path, "r")

            trace_line = None

            # we need a trace line that is complete ore resumed in order to examine
            # which options were used. Keep reading lines until a suitable trace line
            # is found.
            for line in fh:
                line = line.strip()

                # empty lines don't normally appear in trace files but in case this is a
                # made up trace let deal with empty lines.
                if line == "":
                    continue

                # unfinished syscall trace lines don't give us all the info we need to
                # figure out which options are used.
                if "<unfinished ..." in line:
                    continue

                # resuming lines do hold the information we need but they have a
                # slightly different format so let's just skip them too for now.
                if " resumed>" in line:
                    continue

                trace_line = line
                break

        except IOError:
            raise IOError(
                "Unable to read trace file when trying to determine the "
                + "trace options."
            )
        finally:
            fh.close()

        # if no suitable trace line is found to extract the options, then return
        # the initial values of trace_options which assumes that no options were
        # used with the utility.
        if trace_line == None:
            return trace_options

        # check if the general format of a trace line is correct.
        # example: 8085  open("syscalls.txt", O_RDONLY|O_CREAT, 0664) = 3
        if (
            trace_line.find("(") == -1
            or trace_line.find(")") == -1
            or trace_line.find("=") == -1
        ):
            raise Exception("Incorrect format of trace line `" + trace_line + "`")

        # content differences based on the strace options we care about appear in
        # three different parts of the trace line. The first one is before the name
        # of the system call, the second part is witin the parameter set of the
        # system call and the last one is after the return part of the system call,
        # as shown in the examples above.
        m = re.match(r"(.+)\((.+)\)[ ]+=[ ]+[-0-9]+(.*)", trace_line)
        if m:
            upto_first_bracket_string = m.group(1)
            parameters_string = m.group(2)
            after_return_string = m.group(3)
        else:
            raise Exception(
                "Invalid format when parsing parts of trace line `" + trace_line + "`"
            )

        # let's first check for options -o -f -i, -r, -t, -tt and -ttt which impose
        # changes before the name of the system call.
        front_parts = upto_first_bracket_string.split()

        # front_parts should include the name of the syscall, the pid and optionally
        # other information based on options used with the strace utility.
        # HACK HACK HACK:  Parsing fails for complicated calls (e.g.
        # getsockopt(). So we chop off the garbage knowing we will always use
        # the same command switches
        front_parts = front_parts[:2]
        if len(front_parts) < 1 or len(front_parts) > 4:
            # if the string before the first openning bracket has less than 1 parts or
            # more than 4 parts, the format of the trace line is incorrect.
            raise Exception(
                "Invalid format of front part of trace line `" + trace_line + "`"
            )
        elif len(front_parts) == 1:
            # if there is only one part, it must be the name of the system call in
            # which case the pid is not included. So the required -f option must have
            # not been used.
            raise Exception(
                "Required option -f not used in trace line `" + trace_line + "`"
            )

        # remove the name of the system call from the list. Syscall name is always
        # last in the list. We will need the system call name later.
        syscall_name = front_parts.pop()

        # remove the pid from the list. pid is always first in the list.
        pid = front_parts.pop(0)

        # pid should be an integer
        assert pid.isdigit(), "Invalid format of pid in trace line `" + trace_line + "`"

        # Since the pid exists, the -o and -f options must have been set.
        trace_options["output"] = True
        trace_options["fork"] = True

        # front_parts should now have a maximum of 2 values representing options
        # [-t or -tt or -ttt or -r] and -i
        # initialize these options as disabeld and enabled them later.
        trace_options["timestamp"] = None
        trace_options["inst_pointer"] = False

        if len(front_parts) > 0:
            # check if the first value of front_parts corresponds to the -i option, eg [b7782424]
            if "[" in front_parts[0] and "]" in front_parts[0]:
                trace_options["inst_pointer"] = True
                front_parts.pop(0)
            else:
                # if it's not a value of the -i option it must be one of the -t, -tt,
                # -ttt or -r options.
                if ":" in front_parts[0]:
                    # if the value contains a ":" it must be either a -t or a -tt
                    if "." in front_parts[0]:
                        trace_options["timestamp"] = "tt"
                    else:
                        trace_options["timestamp"] = "t"
                else:
                    # if the value does not contain a ":" it must be a -r or a -ttt
                    assert "." in front_parts[0], (
                        "Invalid value `"
                        + front_parts[0]
                        + "` when parsing option -r or -ttt"
                    )

                    # get the number of seconds from the value.
                    seconds = int(front_parts[0][: front_parts[0].find(".")])

                    # seconds since epoch when writting this.
                    epoch_seconds = 1371488434

                    if seconds > epoch_seconds:
                        trace_options["timestamp"] = "ttt"
                    else:
                        trace_options["timestamp"] = "r"

                front_parts.pop(0)

                if len(front_parts) > 0:
                    assert (
                        "[" in front_parts[0] and "]" in front_parts[0]
                    ), "Invalid format when trying to parse value of -i option"
                    trace_options["inst_pointer"] = True
                front_parts.pop(0)

        # all option values were consumed so there should be no more parts left.
        assert (
            len(front_parts) == 0
        ), "Invalid options found when parsing options" + str(front_parts)

        """
        Now let's check if the option -v was used. When the -v option is used, all
        the information of structures used as parameters in a system call, are
        printed in full. Using this fact we can examine a system call that takes a
        structure as a parameter to determine whether or not the -v option is used.
        
        Traces of program executions usually start with the execve system call in
        which case we can examine the parameters of execve to determine whether -v
        option is used. If the trace does not start with the execve system call then
        determining whether the -v option was used is not as straightforward. We can
        certainly keep reading through the trace trying to find a system call that
        uses a structure but for performance reasons we skip this, and just assume
        that the -v option was not used.
        
        Example strace output of the execve system call which is usually the first
        system call displayed in a trace file. The first example shows the strace
        output when the -v option is not used and the second example shows the
        strace output when the -v option is used.
        
        Definition of the execve system call:
        int execve(const char *filename, char *const argv[], char *const envp[]);
        
        Example without the -v option:
        8313  execve("./syscalls", ["./syscalls", "open"], [/* 39 vars */]) = 0
        
        Example with -v option:
        8302  execve("./syscalls", ["./syscalls", "open"], ["SSH_AGENT_PID=23702",
        "GPG_AGENT_INFO=/tmp/keyring-yZgM"..., "TERM=xterm", "SHELL=/bin/bash",
        "XDG_SESSION_COOKIE=f7e455fdc4915"..., "WINDOWID=73407903",
        "GNOME_KEYRING_CONTROL=/tmp/keyri"..., "USER=savvas",
        "LS_COLORS=rs=0:di=01;34:ln=01;36"...,
        "XDG_SESSION_PATH=/org/freedeskto"...,
        "XDG_SEAT_PATH=/org/freedesktop/D"..., "SSH_AUTH_SOCK=/tmp/keyring-
        yZgMt"..., "SESSION_MANAGER=local/savvas-not"...,
        "DEFAULTS_PATH=/usr/share/gconf/u"..., "XDG_CONFIG_DIRS=/etc/xdg/xdg-
        ubu"..., "GPGKEY=D61510C1", "PATH=/usr/lib/lightdm/lightdm:/u"...,
        "DESKTOP_SESSION=ubuntu", "PWD=/home/savvas/Desktop/CHECKAP"...,
        "GNOME_KEYRING_PID=23652", "LANG=en_US.UTF-8",
        "MANDATORY_PATH=/usr/share/gconf/"..., "UBUNTU_MENUPROXY=libappmenu.so",
        "COMPIZ_CONFIG_PROFILE=ubuntu", "GDMSESSION=ubuntu", "SHLVL=1",
        "HOME=/home/savvas", "GNOME_DESKTOP_SESSION_ID=this-is"...,
        "LOGNAME=savvas", "XDG_DATA_DIRS=/usr/share/ubuntu:"...,
        "DBUS_SESSION_BUS_ADDRESS=unix:ab"..., "LESSOPEN=| /usr/bin/lesspipe %s",
        "DISPLAY=:1", "XDG_CURRENT_DESKTOP=Unity", "LESSCLOSE=/usr/bin/lesspipe %s
        %"..., "COLORTERM=gnome-terminal", "XAUTHORITY=/home/savvas/.Xauthor"...,
        "OLDPWD=/home/savvas", "_=/usr/bin/strace"]) = 0
        
        The second example shows how when using the -v options, structure values are
        not abreviated, which is what we use to decide if the trace was collected with 
        the -v option
        """

        # initially assume that the -v option was not used ...
        trace_options["verbose"] = False

        # ... and if this system call is the execve and its parameters_string
        # does not include the strings "[/*" and "*/]" then the -v option must have
        # been used.
        if (
            syscall_name == "execve"
            and "[/*" not in parameters_string
            and "*/]" not in parameters_string
        ):
            trace_options["verbose"] = True

        # finally let's check if the -T option was set. We can do this by checking
        # whether the string after the return part of the system call includes the
        # characters "<" and ">"
        trace_options["elapsed_time"] = False
        if "<" in after_return_string and ">" in after_return_string:
            trace_options["elapsed_time"] = True

        return trace_options

    def parse_trace(self):
        """
        <Purpose>
          Read each line of the trace file and parse it into a Syscall object.

        <Arguments>
          None

        <Exceptions>
          None

        <Side Effects>
          None

        <Returns>
          syscalls:
            A list of Sycall objects, each containing all the information extracted
            from the trace, regarding a specific system call execution.
        """

        # this list will hold all the parsed system calls.
        syscalls = []

        # this list will hold all pending (i.e unfinished) syscalls
        # unfinished_syscalls = []

        try:
            # open the trace file.
            trace_file_handler = open(self.trace_path)

            # process each line of the trace.
            for line in trace_file_handler:
                line = line.strip()

                # skip empty lines
                if line == "":
                    continue

                # skip comments
                if line[0] == "#" or line[0:2] == "//":
                    continue

                if DEBUG:
                    print(line)

                # line_parts = self._parse_line(line, unfinished_syscalls)
                line_parts = self._parse_line(line)

                # the line_parts will be set to None if the trace line is not a valid
                # system call trace. So we just ignore the line entirely.
                if line_parts != None:
                    syscalls.append(
                        Syscall.Syscall(self.syscall_definitions, line, line_parts)
                    )
        finally:
            trace_file_handler.close()

        return syscalls

    def parse_line(self, line):
        line = line.strip()

        # skip empty lines
        if line == "":
            return None

        # skip comments
        if line[0] == "#" or line[0:2] == "//":
            return None

        if DEBUG:
            print(line)

        line_parts = self._parse_line(line)

        if line_parts != None:
            return Syscall.Syscall(self.syscall_definitions, line, line_parts)
        # pid can never be -1, so if -1 then Syscall is none
        return None

    def _parse_line(self, line):
        """
        <Purpose>
          Given a trace line, break it down into the different parts that make up a
          trace line. eg pid, name of system call, parameters, etc

        <Arguments>
          line:
            A string representing the entire trace line. This is not necessarily a
            complete system call, since it is possible for some system calls to be
            unfinished.

          unfinished_syscalls:
            This is a list of all the unfinished system calls pending to be completed. A
            system call can be unfinished and then resumed. When dealing with a
            resuming system call, we need to recall information from when that same
            system call was interrupted i.e. unfinished.

        <Exceptions>
          None

        <Side Effects>
          None

        <Returns>
          line_parts:
            A dictionaly with:
            type:         Type of system call ("completed", "unfinished", "resumed")
            pid:          The process id (eg 8094)
            timestamp:    Start time of the syscall.
            inst_pointer: The instruction pointer at the time of the system call.
            name:         The name of the system call (eg "sendto")
            args:         A list of strings each representing a syscall arguments.
            return:       A list of two items. First item is +/- int or a hex number
                          or a '?' for syscalls that do not return (e.g. _exit
                          syscall). The second item is either None or the error
                          descriptor (string) or a list of returned values.
            elapsed_time: Time spent in syscall.

          None if the line passed is not a valid trace line.

          Notes:
          - timestamp, inst_pointer and elapsed_time are optional and exist only
            if the corresponding option is given. If the option is not given, the
            value is set to None.
          - Format and meaning of timestamp value depends on the timestamp option
            (r/t/tt/ttt).
          - For unfinished syscalls (type="unfinished"), args is an incomplete set
            of arguments. In addition, return and elapsed_time are always set to
            None.
          - For syscalls that don't return, elapsed_time is set to None even if
            the corresponding option is given.
        """

        line_parts = {}

        remaining_line = line

        # pid is the first part of the line.
        line_parts["pid"], remaining_line = remaining_line.split(None, 1)
        assert line_parts["pid"].isdigit(), (
            "Invalid format of parsed pid in line `" + line + "`"
        )

        # Ignore lines that indicate signals. These lines start with either "+++"
        # or "---" (after the pid)
        # Example:
        # 14037 --- SIGCHLD (Child exited) @ 0 (0) ---
        if remaining_line[:3] in ["+++", "---"]:
            return None

        # if the timestamp option is set, the next part of the line will be the
        # timestamp.
        line_parts["timestamp"] = None
        if self.trace_options["timestamp"]:
            line_parts["timestamp"], remaining_line = float(
                remaining_line.split(None, 1)
            )

        # if the inst_pointer option is set, the next part of the line will be the
        # inst_pointer.
        line_parts["inst_pointer"] = None
        if self.trace_options["inst_pointer"]:
            line_parts["inst_pointer"], remaining_line = remaining_line.split(None, 1)
            line_parts["inst_pointer"] = line_parts["inst_pointer"].strip("[]")

        # next, let's parse the name, args and return part of the line, according to
        # the type of the syscall.

        # Example unfinished syscall.
        # 15900 1371634358.110699 [b76e8424] accept(3,  <unfinished ...>
        # 14039 open("/dev/null", O_WRONLY <unfinished ...>

        # Example complete syscall.
        # 15899 1371634358.112335 [b76e8424] socket(PF_INET, SOCK_STREAM, IPPROTO_IP) = 5 <0.000066>

        # Example resumed syscall.
        # 15900 1371634358.112746 [b76e8424] <... accept resumed> {sa_family=AF_INET, sin_port=htons(44289), sin_addr=inet_addr("127.0.0.1")}, [16]) = 4 <0.002020>

        # Example non-returning syscall.
        # 15899 1371634358.112817 [b76e8424] exit_group(0) = ?

        # Example unfinished syscall due to end of program.
        # 15900 1371634358.112850 [????????] nanosleep({...},  <unfinished ... exit status 0>

        if "<unfinished ..." in remaining_line:
            line_parts["type"] = Syscall.Syscall.UNFINISHED

            m = self._re_unfinished_syscall.match(remaining_line)
            if not m:
                raise Exception(
                    "Invalid format when parsing unfinished trace line `" + line + "`"
                )

            line_parts["name"] = m.group(1)
            line_parts["args"] = self._parse_args(m.group(2))
            line_parts["return"] = None

            # save unfinished syscall so that it can be reconstructed when resumed.
            self.unfinished_syscalls.append(
                Syscall.UnfinishedSyscall(
                    line_parts["pid"], line_parts["name"], line_parts["args"]
                )
            )

            # we don't need anything else from the line.
            remaining_line = ""

        elif " resumed>" in remaining_line:
            line_parts["type"] = Syscall.Syscall.RESUMED

            m = self._re_resumed_syscall.match(remaining_line)
            if not m:
                raise Exception(
                    "Invalid format when parsing resumed trace line `" + line + "`"
                )

            line_parts["name"] = m.group(1)

            # there should be a saved unfinished syscall corresponding to this
            # resuming syscall. Let's find its index so we can pop it.
            unfinished_syscalls_index = None
            for index in range(0, len(self.unfinished_syscalls)):
                if (
                    Syscall.UnfinishedSyscall(line_parts["pid"], line_parts["name"], "")
                    == self.unfinished_syscalls[index]
                ):
                    unfinished_syscalls_index = index
                    break

            # if the corresponding unfinished syscall was not found, something must
            # have gone wrong.
            if unfinished_syscalls_index == None:
                raise Exception(
                    "Unfinished syscall not found for resuming syscall `" + line + "`"
                )

            # merge the args of the unfinished syscall with this resuming syscall.
            line_parts["args"] = self.unfinished_syscalls.pop(
                unfinished_syscalls_index
            ).args + self._parse_args(m.group(2))

            line_parts["return"] = m.group(3)
            remaining_line = m.group(4)

        else:
            # this must be a completed/full syscall unlike the previous cases
            line_parts["type"] = Syscall.Syscall.COMPLETE

            m = self._re_complete_syscall.match(remaining_line)
            if not m:
                raise Exception(
                    "Invalid format when parsing completed trace line `" + line + "`"
                )

            line_parts["name"] = m.group(1)
            line_parts["args"] = self._parse_args(m.group(2))
            line_parts["return"] = m.group(3)
            remaining_line = m.group(4)

        # fix the arguments of some specific system calls.
        self._fix_args(line_parts)

        # initialize elapsed_time
        line_parts["elapsed_time"] = None

        # if the type of the syscall is unfinished then there is nothing else to parse.
        if line_parts["type"] == Syscall.Syscall.UNFINISHED:
            return line_parts

        # at this point the remaining line should include the error label eg ENOENT
        # in case of an error, followed by the elapsed time of the system call
        # within angle bracets <>, if the elapsed time option was set. Between
        # these two, there could be extra information within brackets, e.g. a
        # desription of an error or the labels of a flag value.
        #
        # Examles:
        # 16707 1371659593.864971 [b7726cb1] access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory) <0.000023>
        # 16707 1371659593.868020 [b770e424] fcntl64(4, F_GETFL) = 0x402 (flags O_RDWR|O_APPEND) <0.000009>
        # 26896 poll([{fd=4, events=POLLIN}, {fd=0, events=POLLIN}], 2, -1) = 1 ([{fd=4, revents=POLLIN}])

        # the return part should be a positive number or a '-1' or a hex or a '?'
        r = line_parts["return"]
        assert r.isdigit() or r == "-1" or r == "?" or r.startswith("0x"), (
            "Invalid format of return part in trace line `" + line + "`"
        )

        # if the return part is a number let's cast it.
        if r.isdigit() or r == "-1":
            r = int(r)

        # now if the return part is -1 it should be accompanied with an error label
        # which should be the first part of the remaining_line.
        #
        # Example:
        # 14037 recv(6, 0xb7199058, 4096, 0) = -1 EAGAIN (Resource temporarily unavailable)
        error_label = None
        if r == -1:
            error_label, remaining_line = remaining_line.split(None, 1)

            # a basic check on the format of error label is whether it starts with 'E'
            # and it is all-caps.
            assert (error_label.startswith("E") and error_label.isupper()) or (
                "errno" in error_label
            ), ("Invalid format of error_label `" + error_label + "`")
            if "errno" in error_label:
                error_label = error_label + " " + remaining_line.split(None, 1)[0]

        # In some rare cases, a syscall will not return but still include an error
        # label.
        #
        # Example:
        # 14037 <... poll resumed> )              = ? ERESTART_RESTARTBLOCK (To be restarted)
        if r == "?":
            remaining_line = remaining_line.strip()
            # if the remaining line starts with an 'E', then the return part contains
            # an error label.
            if remaining_line.startswith("E"):
                error_label, remaining_line = remaining_line.split(None, 1)
                assert error_label.startswith("E") and error_label.isupper(), (
                    "Invalid format of error_label `" + error_label + "`"
                )

        # we can now form the complete syscall return part, which is the return
        # value of the syscall followed by the error label if one exists, or None if
        # it doesn't.
        line_parts["return"] = (r, error_label)

        # in a few system calls the remaining part holds additional information, e.g in poll system
        # call which has a value-return parameter.
        remaining_line = self._parse_remaining_line(line_parts, remaining_line)

        # finally, if the elapsed_time option is set we should extract the elapsed
        # time data. Because the remaining line could optionally include some
        # unneeded information as shown in the examples above, we'll only extract
        # the data within the angle brackets. No elapsed time is provided in non
        # returning syscalls.
        if self.trace_options["elapsed_time"] and line_parts["return"] != ("?", None):
            line_parts["elapsed_time"] = float(
                remaining_line[
                    remaining_line.rfind("<") + 1 : remaining_line.rfind(">")
                ]
            )

        return line_parts

    def _parse_args(self, args_string):
        """
        <Purpose>
          Given a string containing all the syscall arguments, break it down into a
          list of strings, each representing a separate argument.

        <Arguments>
          args_string:
            A single string containing all the arguments.

        <Exceptions>
          None

        <Side Effects>
          None

        <Returns>
          args_list:
            A list of strings with each string representing a separate system call
            argument.
        """

        args_string = args_string.strip()

        # in unfinished system calls it is possible that the args_string will end with a comma ","
        # with no arguments following this. Let's remove the comma as well.
        args_string = args_string.rstrip(",")

        # initialize an empty list.
        args_list = []

        # if the string of arguments is empty return an empty list of arguments
        if args_string == "":
            return args_list

        # merge wrongly split arguments (i.e if a string argument containted the string ", ")
        args_list = self._merge_quote_args(args_string.split(", "))

        return args_list

    def _fix_args(self, line_parts):
        """
        <Purpose>
          Fix the arguments of some specific system calls.

        <Arguments>
          line_parts:
            The parts of the trace line based on which the changes will occur.

        <Exceptions>
          None

        <Side Effects>
          None

        <Returns>
          None

        """

        # shutdown syscall includes both a number and a string description for the
        # "how" option. Change option number to its corresponding flag.
        #
        # Example shutdown syscall.
        # 7169  shutdown(5, 0 /* receive */) = 0
        # 26896 shutdown(4, SHUT_RD)              = 0
        #
        # In essence, treat:
        # 7169  shutdown(5, 0 /* receive */) = 0
        # as if it was:
        # 7169  shutdown(5, 0) = 0
        if line_parts["name"].startswith("shutdown"):
            # there are three possible options for shutdown.
            shutdown_flags = {0: "SHUT_RD", 1: "SHUT_WR", 2: "SHUT_RDWR"}

            # use the dictionary to change the option number to its corresponding flag
            # by parsing the option number. The option number is the first character
            # of the second argument in the args list.
            if line_parts["args"][1][0].isdigit():
                line_parts["args"][1] = shutdown_flags[int(line_parts["args"][1][0])]

        # Definition of restart_syscall:
        # long sys_restart_syscall(void);
        #
        # Example of restart_syscall
        # 14037 restart_syscall(<... resuming interrupted call ...>) = 1
        if line_parts["name"].startswith("restart_syscall"):
            # set arguments to the empty set since the provided message is not part of
            # the syscall's arguments list.
            line_parts["args"] = []

        """
        TODO:
        # system calls statfs64 or fstatfs64, sometimes include an 
        # unnecessary numeric value as their second parameter. Remove it.
        if syscall_name.startswith("statfs") or syscall_name.startswith("fstatfs"):
          # 22480 statfs64("/selinux", 84, {f_type="EXT2_SUPER_MAGIC", 
          # f_bsize=4096, f_blocks=4553183, f_bfree=741326, f_bavail=510030, 
          # f_files=1158720, f_ffree=509885, f_fsid={-1853641883, 
          # -1823071587}, f_namelen=255, f_frsize=4096}) = 0
          if parameters[1].isdigit():
            parameters.pop(1)
        """

    def _parse_remaining_line(self, line_parts, remaining_line):
        """
        <Purpose>
          Fix the return part of some specific system calls.

        <Arguments>
          line_parts:
            The parts of the trace line based on which the changes will occur.

        <Exceptions>
          None

        <Side Effects>
          None

        <Returns>
          remaining_line:
            The updated remaining line.

        """

        if (
            line_parts["name"].startswith("fcntl")
            and remaining_line.find("(flags ") != -1
        ):
            # the return part of fcntl can be a hex number followed by a set of flag
            # names. we want to keep the flag names as the return part.
            # handle fcntl return part. I.e use the set of flags instead of their hex
            # representation.
            # example:
            # fcntl64(4, F_GETFL) = 0x402 (flags O_RDWR|O_APPEND)
            # replace the hex part: 0x402 with the flags O_RDWR|O_APPEND
            # get the part between '(flags' and ')'
            flags = remaining_line[
                remaining_line.find("(flags ") + 7 : remaining_line.rfind(")")
            ]
            remaining_line = remaining_line[remaining_line.rfind(")") :]

            if "|" in flags:
                flags = flags.split("|")
            line_parts["return"] = (flags, line_parts["return"][1])

        elif (
            line_parts["name"] == "poll" or line_parts["name"] == "ppoll"
        ) and remaining_line.find("([") != -1:
            # 26896 poll([{fd=4, events=POLLIN}, {fd=0, events=POLLIN}], 2, -1) = 1 ([{fd=4, revents=POLLIN}])

            # update the pollfd structure with the revents values.
            pollfds = remaining_line[
                remaining_line.find("([") + 2 : remaining_line.rfind("])")
            ]
            remaining_line = remaining_line[remaining_line.rfind("])") :]

            pollfds = pollfds.split(", ")
            while len(pollfds) != 0:
                fd = pollfds.pop(0)
                revents = pollfds.pop(0)

                # find the pollfs including this fd
                index = 0
                for arg in line_parts["args"]:
                    if arg.find(fd) != -1:
                        line_parts["args"].insert(index + 2, revents)

                    index += 1

        return remaining_line

    def __repr__(self):
        # generate the trace options string.
        trace_options_string = ""
        if self.trace_options["inst_pointer"]:
            trace_options_string += "-i "
        if self.trace_options["timestamp"]:
            trace_options_string += "-" + self.trace_options["timestamp"] + " "
        if self.trace_options["elapsed_time"]:
            trace_options_string += "-T "
        if self.trace_options["output"]:
            trace_options_string += "-o "
        if self.trace_options["fork"]:
            trace_options_string += "-f"

        representation = (
            "<"
            + self.__class__.__name__
            + " trace_path=`"
            + self.trace_path
            + "`"
            + " trace_options="
            + trace_options_string
            + ">"
        )

        return representation
